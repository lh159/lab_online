<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ASR 句置信度展示</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <style>
        body { padding: 20px; }
        .confidence { font-weight: 600; }
    </style>
</head>
<body>
  <div id="app" class="container">
    <div class="d-flex align-items-center mb-3">
      <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f4ac.svg" alt="" style="width:36px;height:36px;margin-right:10px;">
      <h3 class="m-0">ASR 句置信度展示</h3>
      <small class="text-muted ms-3">按字级显示置信度，低置信可编辑并保存</small>
    </div>

    <div class="mb-3">
      <label class="form-label">从目录选择音频</label>
      <select class="form-select" v-model="selectedFile">
        <option value="">-- 选择 --</option>
        <option v-for="f in files" :key="f" :value="f">{{ f }}</option>
      </select>
    </div>

    <div class="mb-3">
      <label class="form-label">或上传音频</label>
      <input class="form-control" type="file" @change="onFileChange" accept="audio/*">
    </div>

    <div class="mb-3">
      <label class="form-label">Ground Truth 文本（可选）</label>
      <textarea class="form-control" rows="3" v-model="groundTruth"></textarea>
    </div>

    <button class="btn btn-primary" @click="analyze" :disabled="loading">
      {{ loading ? '处理中...' : '分析并展示置信度' }}
    </button>

    <hr>

    <div v-if="result">
      <h5>识别结果</h5>
      <p><strong>识别文本：</strong> {{ result.text }}</p>
      <p><strong>Ground Truth：</strong> {{ ground_truth }}</p>

      <h6>按句展示（含字级热力图与可编辑低置信字）</h6>

      <div class="mb-3">
        <label class="form-label">置信度阈值（低于此值标红，百分比）: {{ (threshold*100).toFixed(0) }}%</label>
        <input type="range" class="form-range" min="0" max="100" v-model.number="thresholdPct" @input="onThresholdChange">
      </div>

      <div v-for="(s, sidx) in sentenceCharLists" :key="sidx" class="card mb-2 p-2">
        <div class="mb-1"><strong>句子:</strong> {{ s.text }}</div>
        <div class="mb-2"><strong>句子置信度:</strong> <span class="confidence">{{ (s.confidence*100).toFixed(2) }}%</span></div>

        <div class="d-flex flex-wrap" style="gap:6px;">
          <template v-for="(c, idx) in s.chars">
            <span v-if="editing && editing.sidx === sidx && editing.idx === idx" :key="idx" class="d-inline-block">
              <input class="form-control form-control-sm" style="width:56px;display:inline-block"
                     v-model="editing.value" @blur="commitEdit" @keydown.enter.prevent="commitEdit" />
            </span>
            <span v-else :key="idx"
                  class="char-badge"
                  :title="`字符: ${c.char} — 置信度: ${(c.confidence*100).toFixed(2)}%`"
                  :style="charStyle(c.confidence, c.isLow)">
              <span @click="onCharClick(sidx, idx, c)" style="cursor:pointer; user-select:none;">
                {{ c.char }}
              </span>
            </span>
          </template>
        </div>
      </div>

      <div class="mt-3 d-flex gap-2">
        <button class="btn btn-secondary btn-sm" @click="applyEditsToGroundTruth">将当前字符修改应用到 Ground Truth 文本框</button>
        <button class="btn btn-success btn-sm" @click="saveEdits" :disabled="!canSave()">保存为 Ground Truth 并记录历史</button>
        <button class="btn btn-outline-primary btn-sm" @click="downloadCharMap">下载字级置信度 (JSON)</button>
        <div v-if="saveMessage" class="alert alert-success mb-0 ms-2 py-1 px-2" role="alert">{{ saveMessage }}</div>
      </div>
    </div>

    <div v-if="error" class="alert alert-danger mt-3">{{ error }}</div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          files: [],
          selectedFile: "",
          uploadFile: null,
          groundTruth: "",
          result: null,
          ground_truth: "",
          resultFilename: null,
          loading: false,
          error: "",
          // 阈值 0..1 存储
          threshold: 0.5,
          thresholdPct: 50,
          editing: null,
          localEdits: {}
          ,
          saveMessage: ""
        }
      },
      mounted() {
        this.loadFiles();
      },
      methods: {
        async loadFiles() {
          try {
            const res = await fetch('/audio-list');
            const j = await res.json();
            this.files = j.files || [];
          } catch (e) {
            this.error = '加载音频列表失败: ' + e;
          }
        },
        onFileChange(ev) {
          const f = ev.target.files[0];
          if (f) this.uploadFile = f;
        },
        async analyze() {
          this.loading = true;
          this.error = "";
          this.result = null;
          try {
            const form = new FormData();
            form.append('ground_truth', this.groundTruth || "");
            if (this.uploadFile) {
              form.append('file', this.uploadFile);
            } else if (this.selectedFile) {
              form.append('filename', this.selectedFile);
            } else {
              throw new Error('请先选择目录内文件或上传文件');
            }
            const res = await fetch('/analyze', { method: 'POST', body: form });
            if (!res.ok) {
              const t = await res.text();
              throw new Error(t || 'server error');
            }
            const j = await res.json();
            this.result = j.result;
            this.ground_truth = j.ground_truth;
          this.resultFilename = j.filename || null;
            this.localEdits = {};
            this.editing = null;
          } catch (e) {
            this.error = '分析失败: ' + e.message;
          } finally {
            this.loading = false;
          }
        },
        onThresholdChange() {
          this.threshold = Math.max(0, Math.min(1, this.thresholdPct / 100));
        },
        buildCharListForSentence(s) {
          const chars = [];
          const raw = this.result && this.result.raw_prob ? this.result.raw_prob : [];
          if (raw && Array.isArray(raw) && raw.length > 0) {
            for (const item of raw) {
              if (typeof item === 'number') {
                continue;
              } else if (typeof item === 'object' && item !== null) {
                const keys = Object.keys(item);
                if (keys.length >= 1) {
                  const ch = keys[0];
                  const prob = Number(item[ch]) || 0.0;
                  chars.push({ char: ch, confidence: prob, isLow: prob < this.threshold });
                }
              }
            }
            if (chars.length === 0) {
              for (const ch of s.text.split('')) {
                chars.push({ char: ch, confidence: s.confidence || 0.0, isLow: (s.confidence || 0.0) < this.threshold });
              }
            }
          } else {
            for (const ch of s.text.split('')) {
              chars.push({ char: ch, confidence: s.confidence || 0.0, isLow: (s.confidence || 0.0) < this.threshold });
            }
          }
          return chars;
        },
        charStyle(conf, isLow) {
          const c = Math.max(0, Math.min(1, Number(conf) || 0));
          const hue = Math.round(c * 120);
          const bg = `hsl(${hue}deg, 80%, ${isLow ? 70 : 60}%)`;
          const color = '#000';
          const border = isLow ? '2px solid rgba(255,0,0,0.8)' : '1px solid rgba(0,0,0,0.06)';
          return { background: bg, padding: '6px 8px', 'border-radius': '4px', color, border };
        },
        onCharClick(sidx, idx, c) {
          if (!c.isLow) return;
          this.editing = { sidx, idx, value: c.char };
        },
        commitEdit() {
          if (!this.editing) return;
          const { sidx, idx, value } = this.editing;
          if (!this.localEdits[sidx]) this.localEdits[sidx] = {};
          this.localEdits[sidx][idx] = value;
          const s = this.sentenceCharLists[sidx];
          if (s && s.chars && s.chars[idx]) {
            s.chars[idx].char = value;
            s.chars[idx].isLow = s.chars[idx].confidence < this.threshold;
          }
          this.editing = null;
        },
        applyEditsToGroundTruth() {
          const parts = [];
          for (const s of this.sentenceCharLists) {
            const text = s.chars.map(c => c.char).join('');
            parts.push(text);
          }
          this.groundTruth = parts.join(' ');
        },
        downloadCharMap() {
          const payload = { sentences: this.sentenceCharLists, ground_truth: this.ground_truth };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'char_confidence.json';
          a.click();
          URL.revokeObjectURL(url);
        }
        ,
        canSave() {
          return !!(this.selectedFile || this.resultFilename) && !!this.groundTruth;
        },
        async saveEdits() {
          // Prepare payload
          const filename = this.selectedFile || this.resultFilename;
          if (!filename) {
            this.error = "无法保存：未指定目录内文件名";
            return;
          }
          const payload = {
            filename,
            ground_truth: this.groundTruth,
            edits: this.localEdits
          };
          try {
            const res = await fetch('/save-edits', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!res.ok) {
              const t = await res.text();
              throw new Error(t || 'save failed');
            }
            const j = await res.json();
            this.saveMessage = '已保存';
            setTimeout(() => { this.saveMessage = ""; }, 3000);
          } catch (e) {
            this.error = '保存失败: ' + e.message;
          }
        }
      },
      computed: {
        sentenceCharLists() {
          if (!this.result || !this.result.sentences) return [];
          return this.result.sentences.map((s, idx) => {
            const chars = this.buildCharListForSentence(s);
            if (this.localEdits[idx]) {
              for (const [k, v] of Object.entries(this.localEdits[idx])) {
                const i = Number(k);
                if (chars[i]) chars[i].char = v;
              }
            }
            return { text: s.text, confidence: s.confidence || 0.0, chars };
          });
        }
      }
    }).mount('#app');
  </script>
</body>
</html>

